+ Комментарии должны использоваться, чтобы дать краткий обзор кода и предоставить дополнительную информацию, которую нельзя легко получить из кода непосредственно, удали лишние
+ AbstractArrayStorage
+ LENGTH = 4; - размер в проекте должен быть 10_000
+ public Resume[] storage, public int size; - нельзя делать эти поля публичными, это внутреняя часть реализации хранилища
+ SortedArrayStorage
+ } else if (insert == size) { эта проверка включает проверку
 if (insert == 0 && (storage[insert + 1] == null)) { ее можно удалить
+ int length = (size + 1) - (insert + 1) - можно упростить до size - insert
+ storage[insert] = null; - лишние действие
+ int length = ((size + 1) - 1) - (index + 1); -    size - (index + 1) или size - index - 1
используйте паттерн Шаблонный метод
+ для избавления от дублирования кода перенеси методы save, delete в AbstractArrayStorage из ArrayStorage и SortedArrayStorage, а часть кода что отличается реализуй на подобии getIndex
+ когда переопределяешь(реализуешь) методы, не забывай ставить над ними аннотацию @Override, это защитит от синтаксических ошибок в случае рефакторинга кода

# Занятие 3
### Разбор домашнего задания
+ Просмотр видео
- Коммиты:
    HW1
    Introduce package and encapsulation
    lesson03 HW02

### Объектная модель в Java
+- Просмотр видео
- Коммиты:
    Lesson03 equals&hashCode, static
    Lesson03 implements interface
- Ресурсы просмотреть:
    Модификатор static
    10 заметок о модификаторе static в Java
    Класс Object. Контракт equals/hashCode
    Абстрактные классы (youtube)
    Интерфейсы
    Полиморфизм
    Отличия абстрактного класса от интерфейса
    Дополнительно:
        Что такое полиморфизм?
        Ключевое слово static (youtube)
        Интерфейсы, абстрактные классы, полиморфизм (youtube)
        Разбираемся с hashCode() и equals()

### Сложность алгоритмов
+- Просмотр видео
Временная сложность алгоритма (wiki)
Вычислительная сложность (wiki)
Алгоритмы и структуры данных для начинающих: сложность алгоритмов
Time complexity
Бинарное дерево поиска (youtube)
Дополнительно
    Легко написанная книга по алгоритмам и их сложности Грокаем алгоритмы

### Паттерн проектирования Шаблонный метод
+- Просмотр видео
- Коммиты:
    Lesson03 abstract storage & sorted storage
Ресурсы:

Паттерн проектирования — Шаблонный метод (wiki)
Шаблонный метод (Template Method) (youtube)
Шаблонный метод
Дополнительно
    Книга из известной серии Head First — Паттерны проектирования

### Домашнее задание HW3
+ Просмотр видео
+ Перед тем, как приступить к ДЗ, приведите свой проект в соответствии с коммитами. Обратите внимание, что packages в видео и коммитах — отличаются
- Закончите реализацию AbstractArrayStorage, ArrayStorage, SortedArrayStorage, используя паттерн Шаблонный метод
- В SortedArrayStorage храните элементы отсортированными:
    сортировать весь массив не надо
    не используйте Arrays.sort() или самописные методы для сортировки
    для сортировки воспользуйтесь Arrays.binarySearch (бинарный поиск). Разберитесь с тем, какие значения он возвращает

int binarySearch()
если x >= 0, то найден, индекс ключа
если x < 0, то не найден, индекс x
x возвращаемый int
x = -i - 1
тогда индекс вставки для сохранения порядка сортировки
i = -x - 1

Написать реализации
+ убрать дублирование кода которое образуется после реализации

Алгоритм
save()
рассчет i по getIndex()
if найден (x >= 0)
    не вставляем
    выводим сообщение с элементом и его индексом
if else (i = size)
    вставляем в конец
        на позицию size
else
    вставляем на позицию i

update()
delete()
clear()
getAll()

! LENGTH = 10_000

## Ревью
Resume
+ toStringSuper - в классах модели принято переопределять метод toString, чтобы он кастомизировал вывод объекта модели, метод toStringSuper это избыточно и неправильно, он только усложняет восприятие кода
ArrayStorage
+ начиная с Java7 числа можно писать так 10_000, так улучшается читаемость длинных чисел
+ инициализируй поле хранилища при обьявлении, удали конструктор
+ clear - обнуляй только заполненую часть хранилища
- isPresentInMemory - удали этот метод, он нигде не используется
+ save - не нужно делать вывод об успешном сохранении
+ get - не надо итерироваться по массиву дважды..
  + return null перенеси в блок else
+ delete - удаляешь элементы без проверки их наличия
  + не было требования сохранять порядок элементов при удалении, попробуй использовать более “дешевый “ способ удаления, просто поменяв резюме местами
MainArray
>протестируйте ArrayStorage.update(Resume resume)
+ добавь тест для update в этом тестовом классе
Util
+ этот класс усложнил простой вывод в консоль, в нем нет надобности, обычного sout пока достаточно, в следующих уроках мы вместо них будем бросать исключения
+ Комментарии должны использоваться, чтобы дать краткий обзор кода и предоставить дополнительную информацию, которую нельзя легко получить из кода непосредственно, удали комментарии которые описывают очевидное
+ пиши в начале коммита номер ДЗ - WH2

## Домашнее задание HW2
+ Еще раз прочитайте, как правильно оформлять код
+ Настройте IDEA на автоматическое удаление неиспользуемых импортов
+ Поместите классы в пакеты, как это показано в уроке.
По пакетам - см. Хорстманн Т1, 176 стр. Пакеты не связаны - это контейнеры. Пользуемся import.
+ Реализуйте и протестируйте ru.voothi.webapp.storage.ArrayStorage.update(ru.voothi.webapp.model.Resume resume)
+ Сделайте проверки:
+ в update/delete/get - резюме есть в storage?
+ в save- резюме нет в storage?
+ сделайте в save проверку на переполнение
+ выведите соответствующие предупреждения для всех, указанных выше проверок - System.out.println("ru.voothi.webapp.model.Resume ...")
+ Избавьтесь от дублирования в коде ru.voothi.webapp.storage.ArrayStorage
+ Посмотрите на методы класса java.util.Arrays. Некоторые из них помогут упростить реализацию ваших методов clear() и getAll()
***
?- isElementOfArray и getIndex делают одно и то же, просто возвращают разные значения. isElementOfArray  можно удалить
: Заменить не удалось
+ setSize(SIZE_AFTER_CLEAR);
просто size = 0
***
+ STORAGE_SIZE_CREATE слово CREATE лишнее - это же переменная, а не метод. Глаголов в именах переменных быть не должно
+ counterElementsOfStorage
  можно просто counter или size
+ поле типа int при создании объекта и так автоматически инициализируется 0. явно это делать не нужно
+ в методе int size() { уже ни какая логика не нужно. Просто return counterElementsOfStorage
+ после очистки null выводиться не должны.
    А иначе это означает, что ты
      не обнулил счетчик резюме после очистки
    counterElementsOfStorage = 0;
+ в delete создавать новый массив не нужно. Делай все на текущем
Исходный, заполненный
mass  |1|2|3|4|
index  0 1 2 3

Удалил элемент index = 0
mass  | |2|3|4|
index  0 1 2 3

* Сохранить размерность массива
* Новый не создавать

Сдвиг элементов index + 1 на 1 позицию влево
        <2 3 4
mass  | |2|3|4|
index  0 1 2 3
- STORAGE_SIZE = 10000
***
. Исправить resume.uuid = uuid; прямое обращение. Нарушение принципа ООП - Инкапсуляция.
. Названия классов - ?
. return 0; ru.voothi.webapp.storage.ArrayStorage.java есть нуль, а в switch ru.voothi.webapp.MainArray.java - нет. Почему?
. Почему printAll не в ru.voothi.webapp.storage.ArrayStorage?
Предложение: вынести в отдельную структуру
. printAll() ru.voothi.webapp.MainArray.java переменная all - ? Нет контекста у названия. В ru.voothi.webapp.MainTestArrayStorage.java
её нет.
  . Дублирование кода printAll() в ru.voothi.webapp.MainArray.java, ru.voothi.webapp.MainTestArrayStorage.java
. Название. Лучше поменять на create, судя по текущей реализации в коде. Иначе,
Почему в save() создаем новый экземпляр объекта?
                case "save":
                    resume = new ru.voothi.webapp.model.Resume();
. get ru.voothi.webapp.storage.ArrayStorage.java @Overwrite toString(), кастомно, для вывода массива резюме.
